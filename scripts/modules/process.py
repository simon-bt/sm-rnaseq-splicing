import pandas
import plotly
import numpy
import plotly.express as px
import plotly.graph_objects as go
import seaborn as sns
import matplotlib.pyplot as plt
from matplotlib.patches import Patch

# Figure Template
FIG_TEMPLATE = dict(
    layout=go.Layout(
        autosize=False,
        title_font=dict(family='Arial',
                        size=16),
        font=dict(family='Arial',
                  size=14,
                  color='#1e2125'),
        xaxis=dict(
            showgrid=False,
            ticks='outside',
            ticklen=10,
            tickwidth=2,
            showline=True,
            linecolor='black',
            tickcolor='black',
            mirror=True,
            linewidth=2,
            zeroline=False
        ),
        yaxis=dict(
            showgrid=False,
            ticks='outside',
            ticklen=5,
            tickwidth=2,
            showline=True,
            linecolor='black',
            tickcolor='black',
            mirror=True,
            linewidth=2,
            zeroline=False,
            nticks=10
        ),
        legend=dict(
            font=dict(size=16),
            x=0.5,
            y=1.15,
            orientation='h',
            xanchor='auto',
            yanchor='auto'
        )
    )
)


class ProcessData:
    """
    ProcessData class contains methods for data processing and visualization of splicing quantification data
    generated by VAST-TOOLS software (combine and compare modules). For details about software modules and parameters,
    visit https://github.com/vastgroup/vast-tools.

    Attributes
    ----------
    vast_out : pandas.DataFrame
        vast-tools combine output.
    df_all : pandas.DataFrame
        vast-tools compare output for all events that pass the coverage filter, including events
        that pass the dPSI and range filters.
    df_diff : pandas.DataFrame
        vast-tools compare output for the regulated events that pass the coverage and dPSI filters.
    samples : list
        List of samples.
    group_a : str
        Control group for the comparison.
    group_b : str
        Contrast group for the comparison.

    Methods
    -------
    __length_map(cls, df)
        Process vast-tools combine output table for event-to-length mapping.
    __process_all_data(cls, df_all, df_diff, group_a, group_b, len_map)
        Process vast-tools compare output for all events.
    __process_diff_data(cls, df_diff, samples)
        Process vast-tools compare output for the regulated events.
    __define_events(cls, df)
        Define event type from the VastDB Event IDs.
    scatter_quantlevel(df_all, event_type, group_a, group_b, color_reg, color_unreg)
        Plot scatter of splicing quantification levels for a given event type.
    violin_quantlevel(df_all, group_a, group_b, color_group_a, color_group_b)
        Plot violin distribution of splicing quantification levels for the regulated events.
    distribution_dpsi(df_diff, dpsi, group_a, group_b, color_reg)
        Plot dPSI boxplot distribution for regulated events.
    ridge_dpsi(df_diff, group_a, group_b)
        Plot ridge density distribution of dPSI values for the regulated events.
    heatmap(df_diff, samples, zscore=False)
        Plot heatmap of splicing quantification levels for the regulated events.
    pct_protimpact(df_diff)
        Plot predicted impact on the open reading frame for the regulated events.
    pct_dpsi(df_all, dpsi, color_reg, color_unreg)
        Plot percentage of the regulated events in data that pass the coverage and dPSI filters.
    event_quantlevel(df_diff, samples_a, samples_b, group_a, group_b, color_group_a, color_group_b)
        Plot splicing quantification level in each sample per regulated event.
    data_per_event(df)
        Filter dataframe by event types.
    """

    def __init__(
            self,
            vast_out: pandas.DataFrame,
            df_all: pandas.DataFrame,
            df_diff: pandas.DataFrame,
            samples: list,
            group_a: str,
            group_b: str,
    ):
        """
        Parameters
        ----------
        vast_out : pandas.DataFrame
            vast-tools combine output.
        df_all : pandas.DataFrame
            vast-tools compare output for all events that pass the coverage filter, including events
            that pass the dPSI and range filters.
        df_diff : pandas.DataFrame
            vast-tools compare output for regulated events that pass the coverage and dPSI filters.
        samples : list
            List of samples.
        group_a : str
            Control group for the comparison.
        group_b : str
            Contrast group for the comparison.
        """

        _vast_out = vast_out
        _df_all = df_all
        _df_diff = df_diff
        _samples = samples
        _groupA = group_a
        _groupB = group_b

        _length_map = self.__length_map(_vast_out)
        self.alt_all = self.__process_all_data(_df_all, _df_diff, _groupA, _groupB, _length_map). \
            pipe(self.__define_events)
        self.alt_diff = self.__process_diff_data(_df_diff, _samples). \
            pipe(self.__define_events)

    @classmethod
    def __length_map(
            cls,
            df: pandas.DataFrame
    ) -> pandas.DataFrame:
        """
        Process vast-tools combine output table for event-to-length mapping.

        Parameters
        ----------
        df : pandas.DataFrame
            Dataframe of vast-tools combine output.

        Returns
        -------
        pandas.DataFrame
            Length mapping dataframe.
        """

        return df[['EVENT', 'GENE', 'LENGTH']]

    @classmethod
    def __process_all_data(
            cls,
            df_all: pandas.DataFrame,
            df_diff: pandas.DataFrame,
            group_a: str,
            group_b: str,
            len_map: pandas.DataFrame
    ) -> pandas.DataFrame:
        """
        Process vast-tools compare output for all events.

        Parameters
        ----------
        df_all : pandas.DataFrame
            Dataframe of all events.
        df_diff : pandas.DataFrame
            Dataframe of regulated events
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.
        len_map : pandas.DataFrame
            Event-to-length mapping dataframe.

        Returns
        -------
        pandas.DataFrame
            Processed dataframe for all events.
        """

        alt_all = df_all. \
            drop('CATEGORY', axis=1). \
            rename(columns={'PSI_A': group_a,
                            'PSI_B': group_b,
                            'EventID': 'EVENT'}
                   ). \
            merge(len_map, how='left', on='EVENT')
        alt_all['DIFF'] = alt_all['EVENT']. \
            apply(lambda x: 'Yes' if x in df_diff['EVENT'].tolist() else 'No')

        return alt_all

    @classmethod
    def __process_diff_data(
            cls,
            df_diff: pandas.DataFrame,
            samples: list
    ) -> pandas.DataFrame:
        """
        Process vast-tools compare output for the regulated events.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.
        samples : list
            List of samples.

        Returns
        -------
        pandas.DataFrame
            Processed dataframe for regulated events.
        """

        return df_diff.drop(list(df_diff.filter(regex='-Q').columns), axis=1). \
            set_index(['GENE', 'EVENT', 'COORD', 'LENGTH', 'FullCO', 'dPSI']). \
            filter(items=samples). \
            reset_index()

    @classmethod
    def __define_events(
            cls,
            df: pandas.DataFrame
    ) -> pandas.DataFrame:
        """
        Define event type from the VastDB Event IDs.

        Parameters
        ----------
        df : pandas.DataFrame
            Dataframe with Event IDs.

        Returns
        -------
        pandas.DataFrame
            Dataframe with specified event types.
        """

        events = dict(
            EX='EX',
            INT='RI',
            ALTD='ALT-D',
            ALTA='ALT-A'
        )
        event_names = r'({})'.format('|'.join(events.keys()))
        extracted = df['EVENT'].str.extract(event_names, expand=False).dropna()
        df['TYPE'] = extracted.apply(lambda x: events[x]).reindex(df.index)
        df.loc[(df['LENGTH'] <= 27) & (df['EVENT'].str.contains('EX')), 'TYPE'] = 'MIC'

        return df

    @staticmethod
    def scatter_quantlevel(
            df_all: pandas.DataFrame,
            event_type: str,
            group_a: str,
            group_b: str,
            color_reg: str,
            color_unreg: str
    ) -> plotly.graph_objs.Figure:
        """
        Plot scatter of splicing quantification levels for a given event type.

        Parameters
        ----------
        df_all : pandas.DataFrame
            Dataframe of all events.
        event_type : str
            Event type for data selection.
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.
        color_reg : str
            Color for regulated events.
        color_unreg : str
            Color for unregulated events.

        Returns
        -------
        plotly.graph_objs.Figure
            Scatter plot of splicing quantification levels.
        """

        title_dict = dict(
            EX="Exon Inclusion Levels",
            MIC="Microexon Inclusion Levels",
            RI="Intron Retention Levels"
        )
        axes_dict = dict(
            EX="PSI<br>[Percent Spliced In, %]",
            MIC="PSI<br>[Percent Spliced In, %]",
            RI="PRI<br>[Percent Retained In, %]"
        )
        data_events = df_all[df_all['TYPE'] == event_type]. \
            sort_values('DIFF')

        fig_scatter = px.scatter(
            data_events,
            x=group_a,
            y=group_b,
            color='DIFF',
            color_discrete_sequence=[color_unreg, color_reg],
            title=event_type,
            labels={'DIFF': 'Regulated'}
        )
        fig_scatter.update_layout(
            title={
                'text': title_dict[event_type],
                'y': 0.91,
                'x': 0.5,
                'xanchor': 'center',
                'yanchor': 'top'
            },
            template=FIG_TEMPLATE,
            width=700,
            height=700,
            xaxis=dict(title=f"{group_a} {axes_dict[event_type]}"),
            yaxis=dict(title=f"{group_b} {axes_dict[event_type]}"),
            showlegend=True,
            margin=dict(
                pad=0,
                l=100,
                r=50,
                b=100,
                t=10
            )
        )
        fig_scatter.update_traces(
            marker=dict(
                size=9,
                line=dict(
                    width=1,
                    color=True)
            ),
            selector=dict(
                mode='markers'),
            opacity=0.6
        )
        fig_scatter.add_shape(
            type='line',
            x0=0.5,
            y0=0,
            x1=100,
            y1=100,
            line=dict(
                color='black',
                width=2)
        )

        return fig_scatter

    @staticmethod
    def violin_quantlevel(
            df_all: pandas.DataFrame,
            group_a: str,
            group_b: str,
            color_group_a: str,
            color_group_b: str
    ) -> plotly.graph_objs.Figure:
        """
        Plot violin distribution of splicing quantification levels for the regulated events.

        Parameters
        ----------
        df_all : pandas.DataFrame
            Dataframe of all events.
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.
        color_group_a : str
            Color for Control condition.
        color_group_b : str
            Color for Contrast condition.

        Returns
        -------
        plotly.graph_objs.Figure
            Violin distribution plot.
        """

        _n_events = dict(
            df_all.query('DIFF == \'Yes\'')["TYPE"].value_counts()
        )
        _EX = _n_events["EX"]
        _MIC = _n_events["MIC"]
        _RI = _n_events["RI"]
        data_melt = df_all. \
            query('DIFF == \'Yes\''). \
            melt(
            id_vars=['EVENT', 'GENE', 'TYPE'],
            value_vars=[group_a, group_b],
            value_name='PSI',
            var_name='Condition'
        )
        data_a = data_melt.query(f"Condition == \"{group_a}\"")
        data_b = data_melt.query(f"Condition == \"{group_b}\"")

        show_legend = [True, False, False]
        fig_violin = go.Figure()
        for i in range(0, 3):
            fig_violin.add_trace(
                go.Violin(
                    x=data_a['TYPE'][(data_a['TYPE'] == pandas.unique(data_a['TYPE'])[i])],
                    y=data_a['PSI'][(data_a['TYPE'] == pandas.unique(data_a['TYPE'])[i])],
                    legendgroup=group_a,
                    scalegroup=group_a,
                    name=group_a,
                    side='negative',
                    line_color='black',
                    fillcolor=color_group_a,
                    showlegend=show_legend[i],
                    spanmode='hard'
                )
            )
            fig_violin.add_trace(
                go.Violin(
                    x=data_b['TYPE'][(data_b['TYPE'] == pandas.unique(data_b['TYPE'])[i])],
                    y=data_b['PSI'][(data_b['TYPE'] == pandas.unique(data_b['TYPE'])[i])],
                    legendgroup=group_b,
                    scalegroup=group_b,
                    name=group_b,
                    side='positive',
                    line_color='black',
                    fillcolor=color_group_b,
                    showlegend=show_legend[i],
                    spanmode='hard'
                )
            )
        fig_violin.update_layout(
            template=FIG_TEMPLATE,
            width=700,
            height=700,
            violingap=0,
            violingroupgap=0.2,
            violinmode='overlay',
            yaxis=dict(title='Splicing Quantification Level [%]'),
            xaxis=dict(title=''),
            margin=dict(pad=0, l=100, r=50, b=75, t=10)
        )
        fig_violin.update_traces(
            meanline_visible=True,
            points=False
        )
        fig_violin.update_xaxes(
            categoryorder='array',
            categoryarray=['EX', 'MIC', 'RI'],
            range=[-0.5, 2.5],
            tickvals=["EX", "MIC", "RI"],
            tickangle=0,
            ticktext=[
                f"EX <br>({_EX})",
                f"MIC <br>({_MIC})",
                f"RI <br>({_RI})"
            ]
        )
        fig_violin.update_yaxes(
            range=[-5, 105]
        )

        return fig_violin

    @staticmethod
    def distribution_dpsi(
            df_diff: pandas.DataFrame,
            dpsi: int,
            group_a: str,
            group_b: str,
            color_reg: str
    ) -> plotly.graph_objs.Figure:
        """
        Plot dPSI boxplot distribution for the regulated events.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.
        dpsi : int
            dPSI threshold.
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.
        color_reg : str
            Color for regulated events.

        Returns
        -------
        plotly.graph_objs.Figure
            Boxplot distribution plot.
        """

        _min_dpsi = df_diff["dPSI"].min() - 10
        _max_dpsi = df_diff["dPSI"].max() + 10
        _n_events = dict(df_diff["TYPE"].value_counts())
        _EX = _n_events["EX"]
        _MIC = _n_events["MIC"]
        _RI = _n_events["RI"]

        fig_dpsi = px.box(
            df_diff,
            x='TYPE',
            y='dPSI',
            notched=True,
            title=f"Change in Quantification Level",
            color_discrete_sequence=[color_reg],
            points="all",
            category_orders={
                'TYPE': ['EX', 'MIC', 'RI']
            }
        )
        fig_dpsi.update_layout(
            template=FIG_TEMPLATE,
            width=700,
            height=700,
            yaxis=dict(title=f"Change in Quantification Level<br>[{group_b} vs {group_a}]"),
            xaxis=dict(title=''),
            margin=dict(
                pad=0,
                l=100,
                r=50,
                b=100,
                t=50
            )
        )
        fig_dpsi.update_yaxes(
            range=[_min_dpsi, _max_dpsi]
        )
        fig_dpsi.update_xaxes(
            tickvals=["EX", "MIC", "RI"],
            tickangle=0,
            ticktext=[
                f"EX <br>({_EX})",
                f"MIC <br>({_MIC})",
                f"RI <br>({_RI})"
            ]
        )
        fig_dpsi.add_shape(
            type='line',
            x0=-1,
            y0=dpsi,
            x1=3,
            y1=dpsi,
            line=dict(
                color='darkred',
                width=2
            )
        )
        fig_dpsi.add_shape(
            type='line',
            x0=-1,
            y0=-dpsi,
            x1=3,
            y1=-dpsi,
            line=dict(
                color='darkred',
                width=2
            )
        )
        fig_dpsi.update_traces(
            pointpos=0,
            marker=dict(
                opacity=0.4,
                size=7),
            jitter=0.5
        )

        return fig_dpsi

    @staticmethod
    def ridge_dpsi(
            df_diff: pandas.DataFrame,
            group_a: str,
            group_b: str
    ) -> sns.axisgrid.FacetGrid:
        """
        Plot ridge density distribution of dPSI values for the regulated events.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.

        Returns
        -------
        sns.axisgrid.FacetGrid
            Ridge density distribution plot.
        """

        sns.set_theme(
            style='white',
            rc={'axes.facecolor': (0, 0, 0, 0)}
        )
        pal = sns.color_palette("husl", 5)[:3]

        df = df_diff[["TYPE", "dPSI"]]
        mean_dpsi = df.groupby('TYPE')['dPSI'].mean()
        df['mean_dPSI'] = df['TYPE'].map(mean_dpsi)
        n_events = dict(df_diff['TYPE'].value_counts())
        event_dict = {
            1: f"EX ({n_events['EX']})",
            2: f"MIC ({n_events['MIC']})",
            3: f"RI ({n_events['RI']})"
        }

        fig_ridge = sns.FacetGrid(
            df,
            row='TYPE',
            row_order=['EX', 'MIC', 'RI'],
            hue='mean_dPSI',
            aspect=8,
            height=1.2,
            palette=pal
        )
        fig_ridge.map(
            sns.kdeplot,
            'dPSI',
            bw_adjust=1,
            clip_on=False,
            fill=True,
            alpha=1,
            linewidth=1.5,
            warn_singular=False
        )
        fig_ridge.map(
            sns.kdeplot,
            'dPSI',
            bw_adjust=1,
            clip_on=False,
            color='ghostwhite',
            lw=2,
            warn_singular=False
        )
        fig_ridge.map(
            plt.axhline,
            y=0,
            lw=2,
            clip_on=False
        )
        fig_ridge.fig.subplots_adjust(hspace=-0.3)
        fig_ridge.despine(
            bottom=True,
            left=True
        )
        for i, ax in enumerate(fig_ridge.axes.flat):
            ax.text(
                x=-100,
                y=0.01,
                s=event_dict[i + 1],
                fontweight='bold',
                fontsize=16,
                color=ax.lines[-1].get_color()
            )
        fig_ridge.set_titles("")
        fig_ridge.set(
            xticks=range(-100, 120, 25)
        )
        fig_ridge.set_xlabels(
            label=f"Change in Quantification Level\n[{group_b} vs {group_a}]",
            fontweight='bold',
            size=16
        )
        fig_ridge.set(yticks=[])
        fig_ridge.set_ylabels(label="")
        fig_ridge.despine(
            bottom=True,
            left=True
        )
        fig_ridge.set_xticklabels(
            ax.get_xticklabels(),
            fontsize=14,
            fontweight='bold')

        return fig_ridge

    @staticmethod
    def heatmap(
            df_diff: pandas.DataFrame,
            samples: list,
            zscore: bool = False
    ) -> sns.matrix.ClusterGrid:
        """
        Plot heatmap of splicing quantification levels for the regulated events.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.
        samples : list
            List of samples.
        zscore : bool
            Bool, indicates z-scores transformation, default False

        Returns
        -------
        sns.matrix.ClusterGrid
            Heatmap plot.
        """

        sorter = ["EX", "MIC", "RI"]
        df = df_diff.copy()
        df = df[df["TYPE"].isin(sorter)]
        df["TYPE"] = df["TYPE"].astype("category")
        df["TYPE"] = df["TYPE"].cat.set_categories(sorter)
        df.sort_values("TYPE", inplace=True)

        hmap_df = df[samples].dropna()
        labels = df.loc[hmap_df.index]["TYPE"].astype("str")
        color_mapping = [
            sns.color_palette("husl")[1],
            sns.color_palette("husl")[0],
            sns.color_palette("husl")[4]
        ]
        colors = dict(zip(labels.unique(), color_mapping))
        row_colors = labels.map(colors)
        handles = [
            Patch(facecolor=colors[name]) for name in colors
        ]
        col_width = len(samples) * 0.9

        if not zscore:
            heatmap = sns.clustermap(
                hmap_df,
                figsize=(col_width, 8),
                row_cluster=True,
                dendrogram_ratio=(.25, .05),
                cbar_pos=(1.1, .65, .05, .2),
                method="ward",
                row_colors=row_colors,
                cmap=sns.color_palette(
                    "Oranges",
                    as_cmap=True
                ),
                standard_scale=1,
                yticklabels=False
            )
            heatmap.ax_cbar.set_title('Scaled \nPSI/PRI [%]\n')
        else:
            heatmap = sns.clustermap(
                hmap_df,
                figsize=(col_width, 8),
                row_cluster=True,
                dendrogram_ratio=(.25, .05),
                cbar_pos=(1.1, .65, .05, .2),
                method="ward",
                row_colors=row_colors,
                center=0,
                cmap=sns.diverging_palette(
                    20, 210, l=60,
                    center="light",
                    as_cmap=True
                ),
                z_score=True,
                yticklabels=False
            )
            heatmap.ax_cbar.set_title('z-score \nPSI/PRI [%]\n')

        plt.legend(
            handles,
            colors,
            title='Event Type',
            bbox_to_anchor=(0.45, 1.05),
            bbox_transform=plt.gcf().transFigure,
            loc='right',
            facecolor='white',
            framealpha=0
        )
        plt.setp(heatmap.ax_heatmap.get_xticklabels(), rotation=45)

        return heatmap

    @staticmethod
    def pct_protimpact(
            df_diff: pandas.DataFrame
    ) -> plotly.graph_objs.Figure:
        """
        Plot predicted impact on the open reading frame for the regulated events.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.

        Returns
        -------
        plotly.graph_objs.Figure
            Protein impact plot.
        """

        df_onto = df_diff[~df_diff['IMPACT'].isna()]
        _n_events = dict(df_onto['TYPE'].value_counts())
        _EX = _n_events["EX"]
        _MIC = _n_events["MIC"]
        _RI = _n_events["RI"]
        onto_counts = pandas.DataFrame(
            df_onto. \
                groupby('TYPE')['IMPACT']. \
                value_counts()). \
            rename(columns={'count': 'COUNT'}). \
            reset_index()
        onto_counts['N_EVENTS'] = onto_counts['TYPE'].map(_n_events)
        onto_counts['PCT'] = onto_counts. \
            apply(lambda x: round(x['COUNT'] * 100 / x['N_EVENTS'], 2), axis=1)

        fig_impact = px.bar(
            onto_counts,
            x='TYPE',
            y='PCT',
            color='IMPACT',
            category_orders={
                'TYPE': ['EX', 'MIC', 'RI'],
                'IMPACT': ['ProteinIsoforms', 'ORF-disr.', 'UTRs', 'NonCoding', 'Uncertain']
            },
            labels={'IMPACT': 'Impact'}
        )
        fig_impact.update_layout(
            height=700,
            width=600,
            yaxis=dict(title='% Regulated Events'),
            xaxis=dict(title=''),
            template=FIG_TEMPLATE
        )
        fig_impact.update_xaxes(
            tickvals=["EX", "MIC", "RI"],
            tickangle=0,
            ticktext=[
                f"EX <br>({_EX})",
                f"MIC <br>({_MIC})",
                f"RI <br>({_RI})"
            ]
        )

        return fig_impact

    @staticmethod
    def pct_dpsi(
            df_all: pandas.DataFrame,
            dpsi: int,
            color_reg: str,
            color_unreg: str
    ) -> plotly.graph_objs.Figure:
        """
        Plot percentage of the regulated events in data that pass the coverage and dPSI filters.

        Parameters
        ----------
        df_all : pandas.DataFrame
            Dataframe of all events
        dpsi : int
            dPSI threshold.
        color_reg : str
            Color for regulated events.
        color_unreg : str
            Color for unregulated events.

        Returns
        -------
        plotly.graph_objs.Figure
            Proportion of true regulation plot.
        """

        df_dpsi = df_all[df_all['dPSI'].abs() >= dpsi]
        _n_events = dict(
            df_dpsi['TYPE'].value_counts()
        )
        _EX = _n_events["EX"]
        _MIC = _n_events["MIC"]
        _RI = _n_events["RI"]
        diff_counts = pandas.DataFrame(
            df_dpsi.groupby('TYPE')['DIFF'].value_counts()
        ). \
            reset_index(). \
            rename(columns={'count': 'COUNT'})
        diff_counts['N_EVENTS'] = diff_counts['TYPE'].map(_n_events)
        diff_counts['PCT'] = diff_counts. \
            apply(lambda x: round(x['COUNT'] * 100 / x['N_EVENTS'], 2), axis=1)

        fig_pct_dpsi = px.bar(
            diff_counts,
            x='TYPE',
            y='PCT',
            color='DIFF',
            category_orders={
                'TYPE': ['EX', 'MIC', 'RI'],
                'DIFF': ['Yes', 'No']
            },
            color_discrete_map={
                'Yes': color_reg,
                'No': color_unreg
            },
            labels={'DIFF': 'Regulated'}
        )
        fig_pct_dpsi.update_layout(
            height=700,
            width=600,
            yaxis=dict(title='% All Events'),
            xaxis=dict(title=''),
            template=FIG_TEMPLATE
        )
        fig_pct_dpsi.update_xaxes(
            tickvals=["EX", "MIC", "RI"],
            tickangle=0,
            ticktext=[
                f"EX<br>({_EX})",
                f"MIC<br>({_MIC})",
                f"RI<br>({_RI})"
            ]
        )

        return fig_pct_dpsi

    @staticmethod
    def event_quantlevel(
            df_diff: pandas.DataFrame,
            samples_a: list,
            samples_b: list,
            group_a: str,
            group_b: str,
            color_group_a: str,
            color_group_b: str
    ) -> dict[plotly.graph_objs.Figure]:
        """
        Plot splicing quantification level in each sample per regulated event.

        Parameters
        ----------
        df_diff : pandas.DataFrame
            Dataframe of regulated events.
        samples_a : list
            List of samples for Control condition.
        samples_b : list
            List of samples for Contrast condition.
        group_a : str
            Control condition.
        group_b : str
            Contrast condition.
        color_group_a : str
            Color for Control condition.
        color_group_b : str
            Color for Contrast condition.

        Returns
        -------
        dict[plotly.graph_objs.Figure]
            Dictionary of quantification plots per regulated event.
        """

        events = dict()
        for event in df_diff['EVENT'].unique():
            df_event = df_diff[
                df_diff['EVENT'] == event]
            gene = df_event.iloc[0][0]
            coord = df_event.iloc[0][2]
            length = df_event.iloc[0][3]
            impact = df_event.iloc[0][-2]
            _group_mapping = dict(zip(samples_a.split(','), [group_a] * len(samples_a))) | \
                             dict(
                                 zip(samples_b.split(','), [group_b] * len(samples_b)))
            df_melt = df_event. \
                drop(['TYPE', 'dPSI', 'ENSEMBL_ID'], axis=1). \
                melt(['GENE', 'EVENT', 'COORD', 'LENGTH', 'IMPACT'],
                     value_name='PSI',
                     var_name='SAMPLE')
            df_melt['GROUP'] = df_melt['SAMPLE'].map(_group_mapping)

            fig_event = px.scatter(
                df_melt,
                x='SAMPLE',
                y='PSI',
                color='GROUP',
                category_orders={
                    'SAMPLE': samples_a.split(',') + samples_b.split(',')
                },
                color_discrete_sequence=[color_group_a, color_group_b],
                labels={'GROUP': 'Group', 'SAMPLE': 'Sample'},
                title=f'{gene}-{event} ({length}nt): {coord} ({impact})'
            )
            fig_event.update_layout(
                template=FIG_TEMPLATE,
                height=600,
                width=700,
                margin=dict(
                    pad=0,
                    l=50,
                    r=100,
                    b=100,
                    t=150
                )
            )
            fig_event.update_traces(
                marker=dict(
                    opacity=0.75,
                    size=12)
            )
            events.update({event: fig_event})

        return events

    @staticmethod
    def data_per_event(
            df: pandas.DataFrame,
    ) -> dict[pandas.DataFrame]:
        """
        Filter dataframe by event types.

        Parameters
        ----------
        df : pandas.DataFrame
            Dataframe with event TYPE column for data selection.

        Returns
        -------
        dict[pandas.DataFrame]
            Dictionary of dataframes by event type.
        """

        dfs = {
            x: df.query(f"TYPE == \"{x}\"") for x in ['EX', 'MIC', 'RI', 'ALT-D', 'ALT-A']
        }

        return dfs
